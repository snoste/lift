sort
state =  struct idle ? isIdle |
               boatMovingDown ? isBoatMovingDown |
               boatMovingUP ? isBoatMovingUp;
               %|
  %             boatLifting ? isBoatLifting;

%General components and their states
GateID = struct G0 | G1;
PositionID = struct P00 | P01 | P10 | P11 | P_none;


%Gate to master and master to gate
M2G = struct	setGateOpen(GateID) ? isSetGateOpen;
G2M = struct	gateReady ? isGateReady |
		          gateError ? isGateError;


act
shipPresence0:Bool;
shipPresence1:Bool;
moveShip00;

%Gate subcontroller actions
openGate, closeGate: GateID;




g_recFromMaster, m_sendToGate, communicationM_G : M2G;
m_recFromGate, g_sendToMaster, communicationG_M : G2M;


%--------------------------------------
proc


MasterController(s:state) =
(isIdle(s)->(sum b:Bool.shipPresence0(b).(b==true)-> (MasterController(boatMovingUP))<>MasterController(idle))+
isBoatMovingUp(s)->m_sendToGate(setGateOpen0).
%isBoatMovingDown);


%Gate_Controller_proc
GateController = sum receive:M2G.g_recFromMaster(receive).
	(isSetGateOpen0(receive)-> Gate1_close.g_sendToMaster(gateReady).GateController<>GateController);

Gate1_close = sum b1:Bool.gateSensor0(b1).((b1==false) ->  closeGate(G1) <> Gate1_close);


init
hide ({communicationM_G, communicationG_M},

allow({openGate, closeGate, gateState, communicationG_M, communicationM_G},
%set parallel actions
comm({m_recFromGate | g_sendToMaster -> communicationG_M, g_recFromMaster | m_sendToGate -> communicationM_G},

MasterController(idle) || GateController)));
