sort
state =  struct idle ? isIdle;
				 boatMovingDown ? isBoatMovingDown |
				 boatMovingUP ? isBoatMovingUp ;


%General components and their states
GateID = struct G0 | G1;
PositionID = struct P00 | P01 | P10 | P11 | P_none;


%Gate to master and master to gate
M2G = struct	setGateOpen(GateID) ? isSetGateOpen;
G2M = struct	gateReady ? isGateReady |
		          gateError ? isGateError;


act
shipPresence0:Bool;
shipPresence1:Bool;
moveShip00;

%Gate subcontroller actions
openGate, closeGate: GateID;


goToPos00, goToPos01, goToPos11, gotToPos10;


g_recFromMaster, m_sendToGate, communicationM_G : M2G;
m_recFromGate, g_sendToMaster, communicationG_M : G2M;


%--------------------------------------
proc


MasterController(s:state) =
(isIdle(s)-> goToPos00.m_sendToGate(setGateOpen0).MasterController(boatMovingUp) + goToPos10.m_sendToGate(setGateOpen1).MasterController(boatMovingDown))+
(isBoatMovingUp(s) -> MasterController(idle))+
(isBoatMovingDown(s) -> MasterController(idle));


%Gate_Controller_proc
GateController = sum receive:M2G.g_recFromMaster(receive).(
	(isSetGateOpen0(receive)-> Gate1_close.g_sendToMaster(gateReady).GateController<>GateController)+
	(isSetGateOpen1(receive)-> Gate0_close.g_sendToMaster(gateReady).GateController<>GateController));

Gate1_close = sum b1:Bool.gateSensor0(b1).((b1==false) ->  closeGate(G1) <> Gate1_close);
Gate0_close = sum b1:Bool.gateSensor1(b1).((b1==false) ->  closeGate(G0) <> Gate0_close);

init
hide ({communicationM_G, communicationG_M},

allow({openGate, closeGate, gateState, communicationG_M, communicationM_G},
%set parallel actions
comm({m_recFromGate | g_sendToMaster -> communicationG_M, g_recFromMaster | m_sendToGate -> communicationM_G},

MasterController(idle) || GateController)));
